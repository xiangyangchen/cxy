#  C++

[TOC]



## 说明:

```c++
变量的定义方式： 
    变量类型 变量名称 = 变量初始值;
    // int a = 10;
```

```c++
常量：
    作用: 用于记录程序中不可更改的数据
1. #define 宏常量： #define 常量名 常量值
        通常在文件上方定义 ，表示一下常量
2. const修饰的变量： const 数据类型 常量名 = 常量值
        通常在变量定义前加关键字 const ,修饰该变量为常量， 不可修改
```

内存空间占比大小

```c++
 // 整型
short 2字节 {-2^15 ~ 2^15-1}
int 4字节 {-2^31 ~ 2^31-1}
long long 8字节 {-2^63 ~ 2^63-1}

//浮点型
float 4字节 {7位有效}
double 8字节 {15~16位有效}

//字符
char 1字节 {}

// c风格 字符串 
char string[] = "" 
// c++风格 字符串
string str = ""      // 需要 #include <string>
    
// 布尔
bool 1字节 {非0都为真}
```



### 选择结构

```c++
// if 和 switch 的区别？

// switch 缺点： 判断的时候只能是整形或者字符型，不可以是一个区间
// switch 优点： 结构清晰，执行效率高
```

### 循环结构

```c++
1. while 循环语句
    作用： 满足循环条件， 执行循环语句
    语法： while (循环条件){循环语句}
2. do...while 循环语句
    作用：  满足循环条件， 执行循环语句
    语法： do{循环语句} while(循环条件)；
    注意： 与while的区别在于do...while会先执行一次循环语句，再判断循环条件
3  for 循环语句
    作用： 满足循环条件，执行循环语句
    语法： for(起始表达式;条件表达式；末尾循环体) {循环语句}
```

### 跳转关键字

```c++
// break
// continue
goto 
    作用： 可以无条件跳转语句
    语法： goto 标记;
	解释： 如果标记存在，执行到goto语句时，就会跳转到标记位置
```

## 数组：

>
>
>所谓数组，就是一个集合，里面存放了相同类型的数据元素

```c++
特点： 
   	1 . 数组中的每个数据元素都是相同的数据类型
    2 . 数组是由连续的内存位置组成的 
```

```c++
一维数组的定义方法：
    1. 数据类型 数组名[数组长度]；
    2. 数据类型 数组名[数组长度] = {值1，值2 。。。};
	3. 数据类型 数组名[] = {值1，值2，....};
一维数组数组名：
    用途：
    1. 可以统计整个数组的内存中的长度
    2. 可以获取数组在内存中的首地址
```

### 二维数组

```c++
// 二维数组就是在一维数组上，多加了一个维度

//定义方式
1. 数据类型 数组名[行][列];
2. 数据类型 数组名[行][列] = {{数据1，数据2}， {数据1，数据2}};
3. 数据类型 数组名[行][列] = {数据1，数据2， 数据3，数据4};
4. 数据类型 数组名[][列] = {数据1，数据2， 数据3，数据4};
```



## 函数：

```c++
作用：将一段经常使用的代码封装起来，减少重复代码
    一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。
    
函数的定义一般有五个步骤：
    1. 返回值类型
    2. 函数明
    3. 参数表列
    4. 函数体语句
    5. return 表达式
    
    
返回值类型 函数名（参数列表）{
    函数体语句
       
    return表达式；
}
```





### 常用函数

>
>
>### 常用函数篇

#### sizeof()

```c++
语法： sizeof(数据类型/变量) // sizeof(int) 4字节
```

#### rand()

```c++
srand((unsigned int)time(NULL));       // 随机种子，利用当前的时间生成随机数
int numbers{rand()%100 + 1};           
语法： 数据类型 变量名 = rand() % xx  // 代表取 0~xx  后+xx，代表 起始与结束都＋xx
```



## 指针：

>
>
>### 作用：     可以通过指针间接访问内存

```c++
1. 内存编号是从0开始记录的，一般用十六进制数字表示
2. 可以利用指针变量保存地址

指针变量定义语法：  数据类型 * 变量名；
    
    
const 指针
    1. const 修饰指针 ---常量指针
    	const int * p =&a;
    	特点：指针的指向可以修改，但是指针指向的值不可以改
    2. const 修饰常量 ---指针常量
    	int * const p = &a;
    	特点：指针的指向不可以修改，但是指针指向的值可以改
    3. const 既修饰指针，又修饰常量
        const int * const p = &a;
		特点： 指针的指向和指向的值都不可以改
```



## 结构体：

```c++
结构体属于用户自定义的数据类型，允许用户存储不同的数据类型
    
语法： struct 结构体名 {结构体成员列表}；
通过结构体创建变量的方式有三种：
    struct 结构体名 变量名
    struct 结构体名 变量名 = {成员1值，成员2值...}
定义结构体时顺便创建变量
    
    
    
注意* 
    定义结构体时的关键字是struct 不可忽略
    创建结构体变量时，关键字struct可以省略
    结构体变量利用操作符"." 访问成员
```

### 结构体数组

```c++
作用：
    将自定义的结构体放入到数组中方便维护
语法：
    struct 结构体名 数组名[元素个数] = {{},{},{}...}
```

### 结构体指针

```c++
作用：
    通过指针访问结构体中的成员
利用操作符 "->" 可以通过结构体指针访问结构体属性
```

## c++核心编程:

### 内存分区模型

```c++
c++程序在执行时，将内存大方向划分为4个区域
    1.代码区： 存放函数体的二进制代码，由操作系统进行管理的
    2.全局区： 存放全局变量和静态变量以及常量
    3.栈区： 由编译器自动分配释放，存放函数的参数值，局部变量等
    4.堆区： 由程序员分配和释放，若程序员不释放，程序结束后由操作系统自动回收
    
内存4区意义：
    不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程
```

（程序运行前）：

```c++
在程序编译后，生成的二进制可执行文件，未执行改程序前分为两个区域
    代码区：
    	存放的cpu执行的机器指令
    	代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可
    	代码区是只读的，使其只读的原因是防止程序意外的修改了他的指令
    全局区：
    	全局变量和静态变量存放在此
    	全局区还包括了常量区，字符串常量和其他常量也存放在此
    	该区域的数据在程序执行完毕后由操作系统自动释放
    
总结：
    c++中在程序运行前分为全局区和代码区
    代码区的特点是共享和只读
    全局去中存放全局变量，静态变量，常量
    常量区中存放const修饰的全局变量和字符串常量
```

（程序运行后）：

```c++
栈区：
    由编译器自动分配释放，存放函数的参数值，局部变量等
    注意事项： 不要返回局部变量的地址，栈区开辟的数据由编译器自动释放
堆区：
    由程序猿分配释放，若程序猿不释放，程序结束时由操作系统回收
    在c++中主要利用new在堆区开辟内存+
    new操作符：
    	c++中利用new操作符在堆区开辟数据
    	堆区开辟的数据，由程序猿手动开辟，手动释放，释放利用操作符delete
    语法：
    	new 数据类型
    	利用new创建的数据，会返回该数据对应的类型的指针
```

### 引用

```c++
作用：给变量起别名
语法： 数据类型 &别名 = 原名
    
注意事项：
    引用必须初始化
    引用在初始化后，不可改变
    
引用做函数参数
    作用： 函数传参时，可以利用应用的技术让形参修饰实参
    优点： 可以简化指针修改实参
   
引用做 函数返回值
    作用: 引用是可以作为函数的返回值存在的
    注意： 
        不要返回局部变量引用
    用法： 函数调用作为左值
常量引用： 
        作用：
       		常量引用主要用来修饰形参，防止误操作
        在函数形参列表中， 可以加const修饰形参，防止形参改变实参
```

引用的本质：

​	**引用的本质在C++内部实现是一个指针常量**

## 函数提高：

```C++
函数默认参数
    函数的参数列表中的形参是可以有默认值的
    语法： 返回值类型 函数名 （参数 = 默认值） {}

注意事项：
    1.如果某个位置已经存在默认值，那么这个位置以后从左到右都必须存在默认值
    2.如果函数声明有默认参数，函数实现就不能有默认参数，声明和实现只能有一个默认参数
    
函数占位参数：
    C++ 中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置
    语法：
    	返回值类型 函数名（数据类型）{}
```

### 函数重载

```c++
作用：
    函数名可以相同，提高复用性
函数重载满足条件：
    同一个作用域下
    函数名相同
    函数参数 <类型不同> 或者 <个数不同> 或者 <顺序不同>
注意：
    函数的返回值不可以作为函数重载的条件
    
注意事项：
    引用作为重载条件
    函数重载碰到函数默认参数
```

# 类和对象：

```c++
C++面向对象的三大特性为： 封装，继承， 多态
    
    C++ 认为万事万物都皆为对象， 对象上有其属性和行为
```

## 封装

```c++
封装的意义：
    将属性和行为作为一个整体， 表现生活中的事物
    将属性和行为加以权限控制
封装的意义一：
    在设计类的时候， 属性和行为写在一起，表现事物
  语法： class 类名 { 访问权限 ： 属性 /行为}；
封装的意义二：
      访问权限有三种： 
      	1. public  共有权限       // 均可访问
        2. protected 保护权限	  // 类内可以访问  ，类外不可访问
        3. private 私有权限       // 类内可以访问  ，类外不可访问   不可继承
```

struct 和 class 的区别：

```c++
区别：
    struct 默认权限为共有
    class 默认权限为私有
```

成员属性私有化:

```c++
优点：
    1. 将所以成员属性设置为私有，可以自动控制读写权限
    2. 对于写权限，我们可以检测数据的有效性
```

### 对象的初始化和清理

```c++
构造函数和析构函数：
    安全问题：
     1， 一个对象或者变量没有初始化状态， 对其使用后果是未知的
     2， 同样的使用完一个对象或变量， 没有及时清理， 也会造成一定的安全问题
 c++ 利用了构造函数和析构函数解决上面的问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作，对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现
    
    构造函数： 主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
    析构函数： 主要作用在于对象销毁前系统自动调用，执行一些清理工作
    
    
构造函数语法：
    类名（） {}
	1， 构造函数，没有返回值也不写void
    2,  函数名称与类名相同
    3， 构造函数可以有参数，因此可以发生重载
    4， 程序在调用对象时候会自动调用构造，无需手动调用，而且只会调用一次
 
析构函数语法:
    ~类名(){}
	1， 析构函数，没有返回值也不写void
    2, 函数名称与类名相同，在名称前加上符号~
    3， 析构函数不可以有参数，因此不可以发生重载
    4， 程序在对象销毁前会自动调用析构，无需手动调用，而且只会调用一次
```

- #### 构造函数的分类及调用 

```c++
两种分类方式:
	按参数分为： 有参构造和无参构造
    按类型分为:  普通构造和拷贝构造
三种调用方式：
        括号法
        显示法
        隐式转换法
        
// 注意事项：
        调用默认构造函数时候，不要加（）,否则编译器会认为一个函数的声明，而不是一个对象的实例化
```

- #### 拷贝构造函数调用时机

```c++
C++ 中拷贝构造函数调用时机通常有三种情况：
    使用一个已经创建完毕的对象来初始化一个新的对象
    值传递的方法给函数参数传值
    以值方式返回局部对象
```

>默认情况下，c++编译器至少给一个类添加三个函数
>
>1， 默认构造函数（无参，函数体为空）
>
>2， 默认析构函数（无参，函数体为空）
>
>3， 默认拷贝构造函数，对属性进行值拷贝

### 构造函数的调用规则

- #### 如果用户定义有参数构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造

- #### 如果用户定义构造函数，c++不会再提供其他构造函数

###  深拷贝与浅拷贝

- 浅拷贝： 简单的赋值拷贝操作
- 深拷贝： 在堆区重新申请空间，进行拷贝操作

>
>
>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题



### 初始化列表

```c++
作用：
    c++提供了初始化列表语法，用来初始化属性
语法：
    构造函数（） ： 属性1（值1），属性2（值2）。。。。{}
```



### 类对象作为类成员

```c++
c++ 类中的成员可以使另一个类的对象，我们称该成员为对象成员
    
注意：
    当其他类对象作为本类对象成员，构造时候先构造类对象，再构造自身，析构函数的顺序与构造相反。
```



### 静态成员

>
>
>静态成员就是在成员变量和成员函数前面加上关键字static，称之为静态成员

静态成员变量

- 所以对象共享同一份数据
- 在编译阶段分配内存
- 类内声明，类外初始化

静态成员函数

- 所以对象共享同一个函数
- 静态成员函数只能访问静态成员变量

## C++ 对象模型和this指针：

### 成员变量和成员函数分开存储

```c++
只有在C++中，类内的成员变量和成员函数分开存储
    只有非静态成员变量才属于类的对象上
```

### this指针概念

>this 指针的本质， 是指针常量  指针的指向是不可修改的

```c++
c++ 通过提供特殊的对象指针，this指针，解决上述问题，this指针指向被调用的成员函数所属的对象
this 指针是隐含每一个非静态成员函数内的一种指针
this 指针不需要定义，直接使用即可
    
this指针的用途：
    当形参和成员变量同名时，可用this指针来区分
    在类的非静态成员函数中返回对象本身， 可使用 return *this
```

### 空指针访问成员函数

```c++
c++ 中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针
    如果用到this指针，需要添加判断保证代码的健壮性
```

### const修饰成员函数

```c++
常函数：
    成员函数后加 const 后我们称为这个函数为常函数
    常函数内不可以修改成员属性
    成员属性声明时加 mutable 后，在常函数中依然可以修改
常对象：
    声明对象前加 const 称该对象为常对象
    常对象只能调用常对象
```



##  友元：

>目的：
>
>让一个函数或者类，访问另一个类中私有成员

```c++
关键字： friend
友元的三种实现：
    全局函数做友元
    类做友元
    成员函数做友元
```

##  运算符重载：

>
>
>运算符重载概念: 对已有的运算符重新进行定义，赋予其另外一种功能，以适应不同的数据类型

复习：

```bash
前置递增：
	先改变值
后置递增：
	后改变值
```

### 加号运算符重载

```c++
作用：
    实现两个自定义数据类型相加的运算
```

### 左移运算符

```c++
作用： 
    可以输出自定义数据类型
总结：
    重载左移运算符配合友元可以实现输出自定义数据类型
```
 ### 递增运算符重载
 ```c++
 作用： 
    通过重载递增运算符，实现自己的整形数据
 ```

### 赋值运算符重载

```bash
c++ 编译器至少给一个类添加4个函数
1， 默认构造函数（无参， 函数体为空）
2， 默认析构函数（无参， 函数体为空）
3， 默认拷贝构造函数， 对象属性进行值拷贝
4， 赋值运算符 operator=， 对属性进行值拷贝

如果类中有属性指向堆区， 做赋值操作时也会出现深浅拷贝问题
```

### 关系运算符重载

```bash
作用：
	重载关系运算符，可以让两个自定义类型对象进行比较
```

### 函数调用运算符重载

```c++
函数调用运算符（）也可以重载
由于重载后使用的方式非常像函数的调用，因此称为仿函数
仿函数没有固定写法，非常灵活
```

## 继承

>继承的好处：
>
>​			减少重复的代码

```c++
语法：
    class 子类 ： 继承方式 父类
    子类： 也称为 派生类
    父类： 也称为 基类

派生类中的成员，包含两大部分:
一类是从基类继承过来的，一类是自己增加的成员
从基类继承过来的表现其共性，而新增的成员体现了其个性
    
    
继承方式一共有三种：
    公共继承
    保护继承
    私有继承  
```

继承中的构造和析构顺序如下：

先构造父类，再构造子类，析构的顺序与构造的顺序相反

继承同名成员处理方式：

Q：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

总结：

- 子类对象可以直接访问到子类中的同名成员
- 子类对象加作用域可以访问到父类同名成员
- 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数

Q：继承中同名的静态成员在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方法一致

- 访问子类同名成员， 直接访问即可
- 访问父类同名成员，需要加作用域

总结:

同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式 （通过对象和通过类名）

Q：多继承语法

```c++
语法：
    class 子类：继承方式 父类1, 继承方式 父类2 ...
多继承可能会引发父类中有同名成员出现，需要加作用域区分
// c++ 实际开发中不建议用多继承
```

菱形继承

```c++
菱形继承概念：
    两个派生类继承同一个基类：
    又有某个类同时继承两个派生类
    这种继承被称为菱形继承，或者砖石继承
继承前加 virtual 关键字后， 变为虚基类 vbptr   // -- virtual base pointer
此时公共的父类称为虚基类
    
菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义
利用虚继承可以解决菱形继承问题
```

## 多态

```c++
多态是c++面向对象的三大特性之一
    多态分为两类：
        1， 静态多态： 函数重载和运算符重载属于静态多态，复用函数名
    	2， 动态多态： 派生类和虚函数实现运行时多态
    静态多态和动态多态区别：
    	1， 静态多态的函数地址早绑定  - 编译阶段确定函数地址
    	2， 动态多态的函数地址晚绑定  - 运行阶段确定函数地址
优点：
    代码组织结构清晰
    可读性强 
    利于前期和后期的扩展以及维护
总结：
    c++ 开发提倡利用多态的设计程序架构，因为多态优点很多
```

### 存虚函数和抽象类：

```c++
在多态中， 通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容
因此可以将虚函数改为纯虚函数
    纯虚函数语法： virtual 返回值类型 函数名 （参数列表） = 0；
    当类中有了纯虚函数， 这个类也被称为抽象类
   
抽象类特点：
    1，无法实例化对象
    2， 子类必须重写抽象类中的纯虚函数， 否则也属于抽象类
```

### 虚析构和纯虚析构：

```c++
多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码
    解决方式： 将父类中的析构函数改为虚析构或者纯析构函数
    虚构函数和纯析构函数共性：
    	1，可以解决父类指针释放子类对象
    	2，都需要有具体的函数实现
    虚析构和纯虚析构区别：
    	1，如果是纯虚析构，该类属于抽象类，无法实例化对象
  	虚析构语法：
    virtual ~类名（）{}
	纯虚析构语法：
        virtual ~类名（） = 0；
        //类外
        类名：：类名（）{}
总结：
    1，虚析构或纯虚析构就是用来解决父类指针释放子类对象
    2，如果子类中没有堆区数据，可以不写为虚析构或纯虚析构
    3，拥有纯虚析构函数的类也属于抽象类
```



##  文件篇

>### 文件篇

```c++
程序运行时产生的数据都属于临时数据，程序一旦运行结束就会被释放
    通过文件可以将数据持久化
    c++ 中对文件操作需要包含头文件 <fstream>
    文件类型分为两种：
    1，文本文件： 文件以文本的ASCLL码形式存储在计算机中
    2. 二进制文件： 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂他们
    操作文件的三大类：
    1， ofstream : 写操作
    2， ifstream ： 读操作
    3， fstream :  读写操作
```

### 写文件：

```c++
1，包含头文件
    #include <fstream>
2，创建流对象
    ofstream ofs;
3，打开文件
    ofs.open("文件路径"， 打开方式);
4，写数据
    ofs << "data";
5，关闭文件
    ofs.close();

文件打开方式：
ios::in 为读文件而打开文件
ios::out 为写文件而打开文件
ios::ate 初始位置，文件末尾
ios::app 追加方式写文件
ios::trunc 如果文件已经存在，先删除，在创建
ios::binary 二进制
注意： 文件打开方式可以配合使用， 利用操作符 | 
    比如： ios:binary|ios:out
        
总结：
        文件操作必须包含头文件fstream
        读文件可以利用ofstream,或者fstream类
        打开文件时候需要指定操作文件的路径，以及打开方式
        利用<<可以向文件中写数据
        操作完毕，要关闭文件
```

```c++
// template
#include<iostream>
using namespace std;
#include<fstream>
int main()
{
	/*c++基础\c++文件的读写*/
	ofstream ofs;
	ofs.open("test.txt", ios::out);
	ofs << "姓名：张三" << endl;
	ofs << "年龄：28" << endl;
	ofs << "性别：男" << endl;
	ofs.close();
	return 0;
}
```

### 读文件：

```c++
读文件与写文件步骤类似，但是读取方式相对于比较多
    读取文件步骤如下：
    1，包含头文件
    #include <fstream>
    2，创建流对象
    ifstream ifs;
	3，打开文件病判断文件是否打开成功
        ifs.open("文件路径"，打开方式)；
    4，读数据
        四种方式读取
    5，关闭文件
        ifs.close();


总结：
    读文件可以利用ifstream, 或者fstream类
    利用is_open函数可以判断文件是否打开成功
    close关闭文件
    
// template
// i
    // char buf[1024] = {0};
    // while (ifs >> buf)
    // {
    //     cout << buf << endl;
    // }

// ii 
    // char buf[1024] = {0};
    // while (ifs.getline(buf, sizeof(buf)))
    // {
    //     cout << buf <<endl;
    // }

// iii 
    // string buf;
    // while (getline(ifs, buf))
    // {
    //     cout <<  buf << endl;
    // }
    
// iiii
    char s;
    while ( (s = ifs.get()) != EOF )  // EOF  end of file 
    {
        cout << s;
    }
    
```

### 二进制文件：

>以二进制的方式对文件进行读写操作
>
>打开方式要指定为 ios::binary

- #### 写文件

```c++
二进制方式写文件主要利用流对象调用成员函数 write
    函数原型： ostream& write(const char * buffer, int len);
	参数解释： 字符指针buffer指向内存中一段存储空间，len是读写的字节数
```

- #### 读文件

```c++
二进制方式读文件主要利用流对象调用成员函数read
    函数原型：isstream & read(char * buffer, int len);	
	参数解释：字符指针buffer指向内存中的一段存储空间，len是读写的字节数
```

## C++ 提高编程

泛型编程

### 模板：

>概念：  模板就是建立通用的模具，大大提高复用性

```c++
模板的特点：
    模板不可以直接使用，他只是一个框架
    模板的通用并不是万能的
    
C++ 另一种编程思想称为 泛型编程，主要利用技术就是模板
C++ 提供两种模板机制：函数模板和类模板
```

#### 函数模板：

>作用：  建立一个通用函数，其函数返回值类型和形参类型可以不具体定制，用一个虚拟的类型来代表

```c++
语法： 
    template<typename T>
    函数声明或者定义
解释：
    template -- 声明模板
    typename -- 表面其后面的符号是哟中数据类型，可以用Class代替
    T -- 通用的数据类型，名称可以替换，通常为大写字母
    
总结：
    函数模板利用关键字template
    使用函数模板有两种方式： 自动类型推导，显示指定类型
    模板的目的是为了提高复用性，将类型参数化
```

注意事项：

```c++
自动类型推导，必须推导出一致的数据类型T，才可以使用
模板必须要确定出T的数据类型，才可以使用
```

- #### 普通函数与函数魔板的区别

```c++
普通函数调用时可以发生自动类型转换（隐式类型转换）
函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
如果利用显示指定类型的方式，可以发生隐式类型转换

 总结：
    建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T
```

- #### 调用规则

```c++
如果函数模板和普通函数都可以实现，优先调用普通函数
可以通过空模板参数列表来强调函数模板
函数模板也可以发生重载
如果函数模板可以产生更好的匹配，优先调用函数模板
    
总结：
    既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性
```

- #### 局限性

```c++
模板的通用性并不是万能的
    
总结：
    利用具体化的模板，可以解决自定义类型的通用化
    学习模板并不是为了写模板，而是在STL能运用系统提供的模板
```

### 类模板:

- #### 区别

>类模板和函数模板的区别

```c++
类模板没有自动类型推导的使用方式 只能用显示指定类型方式
类模板在模板参数列表中可以有默认参数
```

- #### 类模板创建时机

```c++
普通类中的成员函数一开始就可以创建
类模板中的成员函数在调用时才创建
```

- #### 类模板对象做函数参数

```c++
一共有三种传入方式
    1，指定传入的类型  --直接显示对象的数据类型
    2，参数模板化      --将对象中的参数变为模板进行传递
    3，整个模板化      --将这个对象类型 模板化进行传递
使用比较广泛的为第一种： 指定传入的类型
```

- #### 类模板与继承

```c++
当类模板碰到继承时，需要注意以下几点：
    当子类继承的父类是一个类模板时，子类在声明的时候，要指出父类中T的类型
    如果不指定，编译器无法给子类分配内存
    如果想灵活指定出父类中T的类型，子类也需要变为类模板
总结：
    如果父类是类模板，子类需要指定出父类中T的数据类型
```

# STL初始

STL诞生：

>长久以来，软件界一直都希望建立一钟可重复利用的东西
>
>C++ 的面向对象和泛型编程思想，目的就是复用性的提升
>
>大多情况下，数据结构和算法都未能有一套标准，导致被迫从事大量重复工作
>
>为了建立数据结构与算法的一套标准，诞生了STL

概念：

>STL （Standard Template Library） 标准模板库
>
>STL 从广义上分为：容器（container）算法（algorithm）迭代器（iterator）
>
>容器和算法之间通过迭代器进行无缝链接
>
>STL几乎所有代码都采用了模板类或者模板函数

STL六大组件

>STL大体分为六大组件，分别是容器 算法 迭代器 仿函数 适配器(配接器) 空间配置器
>
>容器： 各种数据结构， 如 vector list deque set map 等，用来存放数据
>
>算法： 各种常用算法， 如 sort find copy for_each 等
>
>迭代器： 扮演了容器与算法之间的胶合剂
>
>仿函数： 行为类似函数，可作为算法的某种策略
>
>适配器： 一种用来修饰容器或者仿函数或迭代器接口的东西
>
>空间配置器： 负责空间的配置与管理

 STL中容器 算法 迭代器

>容器： 放置数据的东西
>
>STL容器就是将运用最广泛的一些数据结构实现出来
>
>常用的数据结构为: 数组，链表， 树， 栈， 队列， 集合， 映射表等
>
>这些容器分别为序列式容器和关联式容器两种：
>
>​         序列式容器： 强调值的排序，序列式容器中的每个元素均有固定的位置
>
>​         关联式容器： 二叉树结构， 各元素之间没有严格的物理上的顺序关系
>
>算法: 解决问题的数学方法
>
>有限的步骤，解决逻辑或数学上的问题，我们称之为算法（algorithm）
>
>算法分为： 质变算法和非质变算法
>
>质变算法： 是指运算过程中会更改区间内的元素的内容，例如拷贝，替换，删除等
>
>非质变算法:  是指运算过程中不会更改区间内的元素内容，例如查找，计数，遍历，寻找极值等
>
>迭代器：容器和算法之间的粘合剂
>
>提供一种方法，使之能够依序寻访某一个容器所包含的各个元素，而又无需暴漏该容器的内部表示方式
>
>每个容器都有自己的专属的迭代器
>
>迭代器的使用非常类似于指针，初学阶段我们可以先理解迭代器就是指针

常用的容器中迭代器种类为双向迭代器，和随机访问迭代器

支持读写操作 向前/向后操作，跳跃式方式访问任何数据， - 功能最强的迭代器

## 容器算法迭代器初识：

>了解STL中容器 算法 迭代器概念之后，我们利用代码感受STL的魅力
>
>STL最常用的容器就是Vector,可以理解为数组，下面举例如何向这个容器插入数据，并遍历这个容器

### Vector存放内置数据类型：

容器 ：Vector

算法： for_each

迭代器： vector<int>::interator

### String 基本概念：

>本质：
>
>string 是C++ 风格的字符串，而string本质上是一个类

>string 和char * 区别：
>
>char * 是一个指针
>
>string 是一个类，类内部封装了char * ，管理这个字符串，是一个char*型的容器

特点：

- string 类内部封装了很多成员方法
- 例如： 查找find 拷贝copy, 删除 delete,替换replace,插入insert
- string 管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责

#### **string 构造函数：**

构造函数原型：

>功能： 构造 string 

- string();   // 创建一个空的字符串，例如： string str;
- string(const char * s );             // 使用字符串S初始化
- string(const string & str);        // 使用一个string对象初始化另一个string对象
- string(int n, char c );                 // 使用n个字符c初始化

#### **string赋值操作:**

>功能： 给string字符串进行赋值

- string & operator=(const char * s );      // char * 类型字符串 赋值给当前的字符串
- string & operator=(const string & s);    //  把字符串S赋给当前的字符串
- string & operator=(char c);                     // 字符赋值给当前的字符串
- string & assign(const char * s);              // 把字符串s赋值给当前的字符串
- string & assign(const char * s, int n);    // 把字符串s的前n个字符赋给当前的字符串
- string & assign(const string & s);           // 把字符串s赋给当前字符串
- string & assign(int n, char c);                  // 用n个字符c赋给当前字符串

#### **string 字符串拼接：**

>功能： 实现在字符串末尾拼接字符串

- string & operator+=(const char * str);             // 重载+=操作符
- string & operator+=(const char c);                   // 重载+=操作符
- string & operator+=(const string & str);          // 重载+=操作符
- string & append(const char * s);                      // 把字符串s链接到当前字符串结尾
- string & append(const char * s, int n);            // 把字符串s的前n个字符链接到当前字符串结尾
- string & append(const string & s);                   // 同operator+=(const string & str)
- string & append(const string & s, int pos, int n);   //字符串S中从pos开始的n个字符链接到字符串结尾

#### **string查找与替换：**

>功能：
>
>查找： 查找指定字符串是否存在
>
>替换： 在指定的位置替换字符串

- int find(const string & str, int pos = 0) const;                 //查找str第一次出现位置，从pos开始查找
- int find(const char * s, int pos = 0) const;                       // 查找s第一次出现位置，从pos开始查找
- int find(const char * s, int pos, int n) const;                   // 从pos位置查找s的前n个字符第一次位置
- int find(const char c , int pos = 0) const;                         // 查找字符C第一次出现位置
- int rfind(const string & str, int pos= npos) const;          // 查找str最后一次位置，从pos开始查找
- int rfind(const char * s, int pos = npos) const;               // 查找s最后一次出现位置，从pos开始查找
- int rfind(const char * s, int pos, int n) const;                  // 从pos查找S的前n个字符最后一次位置
- int rfind(const char c , int pos = 0) const;                        // 查找字符C最后一次出现位置
- string & replace(int pos, int n, const string & str);         // 替换从pos开始n个字符为字符串str
- string & replace(int pos, int n, const char * s);               // 替换从pos开始的n个字符为字符串s

#### **string 字符串比较**

功能描述：

- 字符串之间比较

比较方式：

- 字符串比较是按字符的ASCLL码进行对比

三种结果:

1.  = 返回 0 
2.  》返回 1
3.  < 返回 -1  

函数原型：

- int compare(const string &s) const;  // 与字符串s比较
- int compare(const char *s) const;   // 与字符串s比较

#### **string 字符串提取**:

string中单个字符存取方式有两种：

- char & operator[](int n); // 通过[]方式取字符
- char & at(int n);     //通过at方式获取字符

#### **string 插入和删除**

>功能描述： 
>
>对 string 字符串进行插入和删除字符操作

函数原型：

- string & insert(int pos, const char * s);    //插入字符串
- string & insert(int pos, const string & str);   // 插入字符串
- string & insert(int pos, int n. char c);      //在指定位置插入n个字符c
- string & erase(int pos, int n = npos);      // 删除从pos开始的n个字符

#### **string 子串**

>功能描述： 从字符串中获取想要的子串

函数原型：

- string substr(int pos = 0, int n = npos) const ; //返回由pos开始的n个字符组成的字符串

### Vector容器：

功能：

- vector 数据结构和数组非常相似，也称为单端数组

vector与普通数组区别：

- 不同之处在于数组是静态空间，而verctor是可以动态扩展

动态扩展：

- 并不是在原空间之后继续接新的空间，而是找更大的空间，然后将原数据拷贝新空间，释放原空间

#### **vector构造函数**：

功能描述：

- 创建vector容器

函数原型：

- vector<T> v ;        //采用魔板实现类实现，默认构造函数
- vector(v.begin(), v.end())；      // 将v[begin(),end()]区间中的元素拷贝给自身
- vector(n, elem)；                // 构造函数将n个elem拷贝给自身
- vector(const vector &vec); //拷贝构造函数

#### **vector赋值操作**：

功能描述：

- 给vector 容器赋值

函数原型：

1. vector & operator=(const vector &vec)   // 重载等号操作符
2. assign(beg, end);       // 将【beg，end】区间中的数据拷贝赋值给本身
3. assign(n.elem);   // 将n个elem拷贝赋值给本身

#### **vector容量大小**：

功能描述：

- 对vector容器的容量和大小操作

函数原型：

- empty();         // 判断容器是否为空
- capacity();         //容器的容量
- size() ;             // 返回容器中元素的个数
- resize(int num);      //重新指定容器长度为num.若容器边长，则以默认值填充新位置， 如果容器变短，则末尾超出容器长度的元素被删除
- resize(int num, elem);  // 重启指定容器的长度为num,若容器边长，则以elem值填充新位置 ，如果容器变短，则末尾超出容器长度的元素被删除

#### **vector插入与删除**：

功能描述：

- 对vector容器进行插入，删除操作

函数原型：

- push_back(ele)；    // 尾部插入元素ele
- pop_back();                      // 删除最后一个元素
- insert(const_iterator pos, ele);      // 迭代器指向位置pos插入元素ele
- insere(const_iterator pos, int count, ele);        // 迭代器指向位置pos插入count个元素ele
- erase(const_iterator pos);       // 删除迭代器指向的元素
- erase(const_iterator start, const_iterator end);       // 删除迭代器从start到end之间的元素
- clear();                                                   // 删除容器中所有元素

#### **vector数据存取：**

功能描述：

- 对vector中的数据的存取操作

函数原型：

- at(int index);     //返回索引index所指的值
- operator[];        //返回索引index所指的数据
- front();             // 返回容器中第一个数据元素
- back();             // 返回容器中最后一个数据元素

#### **vector互换容器**：

功能描述：

- 实现两个容器内元素进行互换

函数原型：

- swap(vec);           //将vec与本身的元素互换

#### **vector预留空间**：

功能描述：

- 减少vector 在动态扩展容量时的扩展次数

函数原型：

- reserve(int len); // 容器预留len个元素长度，预留位置不可初始化，元素不可访问

### deque容器：

#### 	deque容器基本概念：

>deque 容器没有容量概念

功能：

- 双端数组，可以对头端进行插入删除操作 

deque与vector区别：

- vector对于头部的插入删除效率低，数据量越大，效率越低
- deque相对而言,对头部的插入删除数据比vector快
- vector访问元素时的速度会被deque快，这和两者内部实现有关

deque内部工作原理：

```c++
deque 内部有一个中控器，维护内端缓冲区中的内容，缓冲区中存放真实数据
    中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间
```

- deque容器的迭代器也是支持书记访问的

  #### 功能描述

  - deque容器构造

  函数原型：

  - deque<T> deqT;           //默认构造形式
  - deque(beg,end);            // 构造函数将[beg,end]区间中的元素拷贝给自身
  - deque(n,elem);              // 构造函数将n个elem拷贝给本身
  - deque(const deque &deq);   // 拷贝构造函数

  

  #### deque 赋值操作：

  功能描述：

  - 给deque容器进行赋值

  函数原型：

  - deque&--operator = (const deque &deq);        // 重载等号操作符
  - assign(beg,end);                //将[beg,end]区间中的数据拷贝赋值给本身
  - assign(n,elem);                // 将n个elem拷贝赋值给本身

  #### deque大小操作：

  功能描述：

  - 对deque容器的大小进行操作

  函数原型：

  - deque.empty();    //判断容器是否为空
  - deque.size()；      // 返回容器中元素的个数
  - deque.resize(num);      // 重新指定容器的长度为num,若容器变长，则以默认值填充新位置，如果容器变短，则末尾超出容器长度的源被删除
  - deque.resize(num, elem);        // 重新指定容器的长度为num,若容器变长，则以elem值填充新位置，如果容器变短，则末尾超出容器长度的源被删除

#### 	deque插入和删除：

功能描述：

- 向deque容器中插入和删除数据

函数原型：

两端插入操作：

- push_back(elem);       //在容器尾部添加一个数据
- push_front(elem);        // 在容器头部插入一个数据
- pop_back(elem);      //在容器尾部删除一个数据
- pop_front(elem);      // 在容器头部删除一个数据

指定位置操作：

- insert(pos,elem);              //在pos位置插入一个elem元素的拷贝,返回新数据的位置
- insert(pos,n,elem);       //在pos位置插入n个 elem数据，无返回值
- inser(pos,beg,end);           //在pos位置插入[beg,end]区间的数据，无返回值
- clear();                 //清空容器中的所有数据
- erase(beg,end)；      // 删除[beg,end]区间的数据，返回下一个数据的位置
- erase(pos);                 // 删除po位置的数据，返回下一个数据的位置

#### deque数据存取：

功能描述:

- 对deque中的数据的存取操作

函数原型：

- at(int indx);              //返回索引index所指的数据
- operator[];                // 返回索引index所指的数据
- front();                    // 返回容器中第一个数据元素
- back();                   // 返回容器中最后一个数据元素

#### deque排序：

功能描述：

- 利用算法实现对deque容器进行排序

算法：

- sort(iterator beg, iterator end)   // 对beg和end区间内的元素进行排序

### stack 容器

#### stack基本概念：

概念： stack是一种先进后出（first in last out .filo）的数据结构，它只有一个出口栈中只有顶部元素才可以被外界使用，因此栈不允许有遍历行为

栈中进入数据称为入栈 push

栈中弹出数据称为出栈 pop

#### stack常用接口：

>功能描述： 栈容器常用的对外接口

构造函数： 

- stack<T> stk;           // stk 采用模板类实现，stack对象的默认构造形式
- stack(const stack &stk);             //拷贝构造函数

赋值操作：

- stack& operator=(const stack &stk);           //重载等号操作符

数据存取：

- push (elem);          // 向栈顶添加元素
- pop();            // 从顶栈移除第一个元素
- top();              // 返回栈顶元素

大小操作：

- empty();           // 判断堆栈是否为空
- size();                    //返回栈的大小

### queue容器

#### queue基本概念：

>概念： queue是一种先进先出(first in first out  fifo)的数据结构，他有两个出口
>
>队列中只有对头和对尾才可以被外界使用，因此队列中不允许有遍历行为
>
>队列中进数据为 入队 push
>
>队列中出数据为 出队 pop

#### queue常用接口：

>功能描述： 栈容器常用的对外接口

构造函数：

- queue<T>que；       // queue采用模板类实现，queue对象的默认构造形式
- queue(const queue &que);  // 拷贝构造函数

赋值操作：

- queue &operator=(const queue &que);        //重载等号操作符

数据存取：

- push(elem);        //往对尾添加元素
- pop();               //从队头移除第一个元素
- back();                 //返回最后一个元素
- front();                //返回第一个元素

大小操作：

- empty();            //判断堆栈是否为空
- size();            // 返回栈的大小

### list容器

#### list基本概念：

功能： 将数据进行链式存储

链表（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的

链表的组成：链表是由一系列结点组成

结点的组成： 一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域

STL中的链表是一个双向循环链表 

由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于双向迭代器

list的优点：

- 采用动态存储分配，不会造成内存浪费和溢出
- 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

list的缺点：

- 链表灵活，但是空间（指针域）和时间（遍历）额外耗费较大

list有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的

总结: STL中list和vector是两个最常被使用的容器，各有优缺点

####  list构造函数：

功能描述:

- 创建list容器

函数原型：

- list<T> lst;    // list采用模板类实现，对象的默认构造形式
- list(begin,end);    //构造函数将(begin,end)区间的元素拷贝给自身
- list(n,elem);     // 构造函数将n个elem拷贝给本身
- list(const list &lst)；   //拷贝构造函数

#### list赋值和交换:

功能描述：

- 给list容器进行赋值，以及交换list容器

函数原型：

- assign(begin,end);     // 将(begin,end)区间中的数据拷贝赋值给本身
- assign(n,elem);       // 将n个elem拷贝赋值给本身
- list &operator=(const list &lst)         // 重载 等号操作符
- swap(lst);             //将lst与本身元素互换

#### list容器的大小操作：

功能描述：

- 对list容器的大小进行操作

函数原型：

- size();            //返回容器中元素的个数
- empty();           // 判断容器是否为空
- resize(num);        // 重新指定容器的长度为num，若容器边长，则以默认值填充新位置，如果容器变短，，则超出部分删除
- resize(num,elem);   // 重新指定容器的长度为num,若容器边长，则以elem填充新位置，如果容器变短，则超出部分删除

#### list插入和删除：

功能描述:

- 对list容器进行数据的插入和删除

函数原型:

- push_back(elem);             // 在容器尾部加入一个元素
- pop_back();                      // 删除容器中最后有个元素
- push_front();                    // 从容器开头插入一个元素
- pop_front();                         // 从容器开头移除一个元素
- insert(pos,elem);                 // 在pos位置插入elem元素的拷贝，返回新数据的位置
- insert(pos,n,elem);             //  在pos位置插入n个elem数据，无返回值
- insert(pos,beg,end);             // 在pos位置插入（{beg,end}）区间的数据，无返回值
- clear();                           // 移除容器的所有数据
- erase(beg,end);         //删除{beg,end}区间的数据，返回下一个数据的位置
- erase(pos);               //删除pos位置的数据，返回下一个数据的位置
- remove(elem);       // 删除容器中所有与elem值匹配的元素

#### list数据存取：

功能描述:

- 对list容器中的数据进行存取

函数原型：

- front();          // 返回第一个元素
- back();              // 返回最后一个元素

#### list反转与排序：

功能描述：

- 将容器中的元素反转，以及将容器中的数据进行排序

函数原型：

- reserve();      //反转列表 
- sort();            // 链表排序

### set/multiset容器

#### set基本概念：

简介：

- 所有元素都会在插入时自动被排序

本质：

- set/multiset属于关联式容器，底层结构是用二叉树实现

set和multiset区别：

- set不允许容器中有重复的元素
- multiset允许容器中有重复的元素

#### set构造和赋值：

功能描述：

- 创建set容器以及赋值

构造:

- set<T>st;      // 默认构造函数
- set(const set &st);  //拷贝构造函数

赋值：

- set &operator=(const set &st);   //重载等号操作符

#### set大小与交换：

功能描述：

- 统计set容器大小以及交换set容器

函数原型：

- size()       // 返回容器中元素的数目
- empty()       // 判断容器是否为空
- swap()     // 交换两个集合容器

####  set插入和删除：

功能描述：

- set 容器进行插入数据和删除数据

函数原型：

- insert(elem);         // 在容器中插入数据
- clear();          // 清空所有元素
- erase(pos);               //删除pos迭代器所指的元素，返回下一个元素的迭代器
- erase(beg,end);            //删除区间[beg,end]的所有元素， 返回下一个元素的迭代器
- erase(elem);              //删除容器中值为elem的元素

#### set查找和统计：

功能描述：

- 对set容器进行查找数据以及统计数据

函数原型：

- find(key);              //查找key是否存在，若存在，返回该建的元素的迭代器；若不存在，返回set.end();
- count(key);            // 统计key的元素个数

#### set和multiset的区别：

学习目标：

- 掌握set和multiset的区别

区别：

- set不可以插入重复数据，而multiset可以
- set插入数据的同时会返回插入结果，表示插入成功
- multiset不会检测数据，因此可以插入重复数据

#### pair对组创建：

功能描述：

- 成对出现的数据，利用对组可以返回两个数据

两种创建方式：

- pair<type, type> p (value1, value2); 
- pair<type,type> p = make_pair(value1, value2);

#### set容器排序：

学习目标：

- set容器默认排序规则从小到大，掌握如何改变排序规则

主要技术点：

- 利用仿函数，可以改变排序规则

### map/multimap容器

#### map基本概念：

简介：

- map中所有元素都是pair
- pair中第一个元素为key(键值)，起到索引作用，第二个元素为value(实值)
- 所有元素都会根据元素的键值自动排序

本质：

- map/mlutimap 属于关联式容器，底层结构是用二叉树实现

优点：

- 可以根据key值快速找到value值

map/multimap区别：

- map不允许容器中有重复key值元素
- multimap 允许容器中有重复key值元素

#### map构造和赋值：

功能描述：

- 对map容器进行构造和赋值操作

函数原型：

构造：

- map<T1,T2> mp;        //map 默认构造函数
- map<const map &mp>;      // 拷贝构造函数

赋值：

- map& operator=(const map &mp);     // 重载等号操作符

#### map大小与交换：

功能描述：

- 统计map容器大小以及交换map容器

函数原型：

- size();          // 返回容器中元素的数目
- empty();        // 判断容器是否为空
- swap();          //交换两个集合容器

####  map插入和删除：

功能描述：

- map 容器进行插入数据和删除数据

函数原型：

- insert(elem);         // 在容器中插入数据
- clear();          // 清空所有元素
- erase(pos);               //删除pos迭代器所指的元素，返回下一个元素的迭代器
- erase(beg,end);            //删除区间[beg,end]的所有元素， 返回下一个元素的迭代器
- erase(key);              //删除容器中值为key的元素

#### map查找和统计：

功能描述：

- 对map容器进行查找数据以及统计数据

函数原型：

- find(key);              //查找key是否存在，若存在，返回该建的元素的迭代器；若不存在，返回set.end();
- count(key);            // 统计key的元素个数

#### map容器排序：

学习目标：

- map容器默认排序规则从小到大，掌握如何改变排序规则

主要技术点：

- 利用仿函数，可以改变排序规则
